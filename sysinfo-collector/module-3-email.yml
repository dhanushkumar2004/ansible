---
# ==========================================================
# AWX System Info Collector & Mailer (Trusted Host Version)
# ==========================================================

- name: Collect detailed system info from all Ubuntu hosts
  hosts: all
  gather_facts: yes
  become: yes
  become_user: root
  become_method: sudo

  tasks:

    ####################################################################
    # --- REQUIRED TOOLS (Robust Install) ------------------------------
    ####################################################################
    - name: Ensure required packages are installed (robust and safe)
      block:
        - name: Check if required binaries already exist
          stat:
            path: "{{ item }}"
          register: pkg_binaries
          loop:
            - /usr/sbin/dmidecode
            - /usr/bin/lsblk
            - /usr/bin/lsb_release
          changed_when: false

        - name: Installing tools if missing (quiet mode)
          apt:
            name:
              - dmidecode
              - util-linux
              - lsb-release
            state: present
            update_cache: yes
            force_apt_get: yes
          environment:
            DEBIAN_FRONTEND: noninteractive
          when: >
            not (pkg_binaries.results | selectattr('stat.exists', 'equalto', true) | list | length == 3)
          async: 180
          poll: 10

      rescue:
        - debug:
            msg: "‚ö†Ô∏è Package installation failed or timed out; continuing with available tools."

    ####################################################################
    # --- CPU INFO -----------------------------------------------------
    ####################################################################
    - name: Get CPU model name
      shell: "lscpu | awk -F: '/Model name/ {print $2}' | sed 's/^ *//'"
      register: cpu_model
      changed_when: false

    ####################################################################
    # --- MEMORY INFO --------------------------------------------------
    ####################################################################
    - name: Get RAM slot usage and memory type from dmidecode
      shell: |
        total_slots=$(dmidecode -t memory | grep -E '^[[:space:]]*Memory Device' | wc -l)
        used_slots=$(dmidecode -t memory | grep -A5 'Memory Device' | grep -E 'Size: [1-9]' | wc -l)
        mem_type=$(dmidecode -t memory | awk -F: '/^[[:space:]]*Type:/{gsub(/^[ \t]+/, "", $2); if($2!="Unknown" && $2!="") {print $2; exit}}')
        [ -z "$mem_type" ] && mem_type="Unknown"
        echo "$used_slots/$total_slots,$mem_type"
      register: ram_info
      changed_when: false
      args:
        executable: /bin/bash

    ####################################################################
    # --- STORAGE INFO -------------------------------------------------
    ####################################################################
    - name: Collect block device info and classify drives
      shell: |
        total=0
        out=""
        while read -r name size rota type; do
          if [ "$type" != "disk" ]; then continue; fi
          gb=$(awk "BEGIN {printf \"%.2f\", $size/1024/1024/1024}")
          if [ "$rota" = "0" ]; then kind="SSD"; else kind="HDD"; fi
          out="$out $name:${kind}(${gb}GB)"
          total=$(awk "BEGIN {printf \"%.2f\", $total + $gb}")
        done < <(lsblk -b -d -o NAME,SIZE,ROTA,TYPE | tail -n +2)
        echo "$total,$out"
      register: disk_info
      changed_when: false
      args:
        executable: /bin/bash

    ####################################################################
    # --- SAVE SYSINFO FACT -------------------------------------------
    ####################################################################
    - name: Save system info as structured fact
      set_fact:
        collected_sysinfo:
          hostname: "{{ ansible_hostname }}"
          cpu: "{{ cpu_model.stdout | default('N/A') }}"
          ram_mb: "{{ ansible_memtotal_mb }}"
          ram_slots: "{{ (ram_info.stdout.split(',')[0]) | default('N/A') }}"
          ram_type: "{{ (ram_info.stdout.split(',')[1]) | default('Unknown') }}"
          storage_gb: "{{ (disk_info.stdout.split(',')[0]) | default('0') }}"
          drives: "{{ (disk_info.stdout.split(',', 2)[1]) | default('N/A') }}"

    ####################################################################
    # --- DISPLAY SUMMARY ----------------------------------------------
    ####################################################################
    - name: Display concise system summary
      debug:
        msg: |
          üñ•Ô∏è Hostname: {{ collected_sysinfo.hostname }}
          üß† CPU: {{ collected_sysinfo.cpu }}
          üíæ RAM: {{ collected_sysinfo.ram_mb }} MB
          üî¢ Slots/Type: {{ collected_sysinfo.ram_slots }} ({{ collected_sysinfo.ram_type }})
          üì¶ Storage: {{ collected_sysinfo.storage_gb }} GB
          üíΩ Drives: {{ collected_sysinfo.drives }}


# ==========================================================
# MODULE 2 - Aggregate results and send email (delegated)
# ==========================================================
- name: Aggregate reports and send via trusted host
  hosts: all
  gather_facts: no
  become: true
  become_user: dhanushkumar.rb
  run_once: true

  vars:
    report_timestamp: "{{ lookup('pipe', 'date +%Y-%m-%d_%H-%M-%S') }}"
    report_dir: "/home/dhanushkumar.rb/hosts-info-ansible"
    csv_file: "{{ report_dir }}/sysinfo_report_{{ report_timestamp }}.csv"
    json_file: "{{ report_dir }}/sysinfo_report_{{ report_timestamp }}.json"
    smtp_host: "smtpout.secureserver.net"
    smtp_port: 587
    mail_to: "recipient@domain.com"
    subject: "AWX Sysinfo Report - {{ report_timestamp }}"

  tasks:

    - name: Aggregate and email from trusted host
      delegate_to: 192.168.2.129
      become_user: dhanushkumar.rb
      block:

        - name: Ensure report directory exists
          file:
            path: "{{ report_dir }}"
            state: directory
            mode: '0755'

        - name: Aggregate data for report
          set_fact:
            data_list: "{{ hostvars | dict2items | map(attribute='value.collected_sysinfo') | select('defined') | list }}"

        - name: Write JSON report
          copy:
            dest: "{{ json_file }}"
            content: "{{ data_list | to_nice_json }}"
            mode: '0644'

        - name: Write CSV report
          copy:
            dest: "{{ csv_file }}"
            content: |
              "Hostname","CPU","RAM_MB","RAM_Slots","RAM_Type","Storage_GB","Drives"
              {% for i in data_list %}
              "{{ i.hostname }}","{{ i.cpu }}","{{ i.ram_mb }}","{{ i.ram_slots }}","{{ i.ram_type }}","{{ i.storage_gb }}","{{ i.drives }}"
              {% endfor %}
            mode: '0644'

        - name: Confirm reports exist before mailing
          stat:
            path: "{{ item }}"
          loop:
            - "{{ csv_file }}"
            - "{{ json_file }}"
          register: report_files

        - name: Verify file presence
          fail:
            msg: "File {{ item.stat.path }} not found on {{ inventory_hostname }}!"
          when: not item.stat.exists
          loop: "{{ report_files.results }}"

        - name: Display generated file names
          debug:
            msg: |
              ‚úÖ Reports generated on {{ inventory_hostname }}:
              üìÑ CSV: {{ csv_file }}
              üìÑ JSON: {{ json_file }}

        - name: Send email with attachments (Python)
          shell: |
            python3 - <<'EOF'
            import smtplib, ssl, os
            from email.mime.text import MIMEText
            from email.mime.multipart import MIMEMultipart
            from email.mime.base import MIMEBase
            from email import encoders

            sender = "{{ smtp_user }}"
            password = "{{ smtp_pass }}"
            recipient = "{{ mail_to }}"
            ts = "{{ report_timestamp }}"
            body = f"Attached are the latest system reports collected by AWX generated on {ts}.\n\nRegards,\nansible team"
            subject = "{{ subject }}"

            msg = MIMEMultipart()
            msg["From"] = sender
            msg["To"] = recipient
            msg["Subject"] = subject
            msg.attach(MIMEText(body, "plain"))

            for path in ["{{ csv_file }}", "{{ json_file }}"]:
                with open(path, "rb") as f:
                    part = MIMEBase("application","octet-stream")
                    part.set_payload(f.read())
                encoders.encode_base64(part)
                part.add_header("Content-Disposition", f"attachment; filename={os.path.basename(path)}")
                msg.attach(part)

            ctx = ssl.create_default_context()
            with smtplib.SMTP("{{ smtp_host }}", {{ smtp_port }}) as server:
                server.starttls(context=ctx)
                server.login(sender, password)
                server.sendmail(sender, recipient, msg.as_string())

            print(f"üìß Email sent successfully to {recipient}")
            EOF
          args:
            executable: /bin/bash
